#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import json
import time

# pads the name with null bytes at the end
def pad(name):
    result = '\0' + name
    while len(result) < 108:
        result += '\0'
    return result

if __name__ == "__main__":
    id = sys.argv[1]
    LAN = sys.argv[2:]

    class Bridge(object):
        def __init__(self, id, lan):
            self.id = id
            self.root = id
            self.cost = 0
            self.sockets = []
            self.root_port = 0
            self.bridge_ports = {}
            self.closed_ports = []
            self.routing_table = {}
            #only needed for testing
            self.lan_ports = {}
            for x in range(len(lan)):
                s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
                s.connect(pad(lan[x]))
                self.lan_ports[str(s.fileno())] = lan[x]
                self.sockets.append(s)

        def update_bridge(self, message_root, message_cost, message_id, port_number):
            time_since_bpdu = time.time()
            self.root = message_root
            self.cost = message_cost + 1
            self.root_port = port_number
            self.send_bpdu()

        def send_bpdu(self):
            for s in self.sockets:
                bpdu_message = {"source": self.id, "dest": 'ffff', "type": 'bpdu',
                                "message": {"id": self.id, "root": self.root, "cost": self.cost}}
                s.send(json.dumps(bpdu_message))

        def recieve_bpdu(self, data, port_number):
            message = data['message']
            message_root = message['root']
            message_cost = message['cost']
            message_id = message['id']

            #if self.id != message_id:
            if port_number in self.bridge_ports:
                add_bridge = True
                for bridge_port in self.bridge_ports[port_number]:
                    if bridge_port['id'] == message_id:
                        add_bridge = False
                        bridge_port['cost'] = message_cost
                        break
                if add_bridge:
                    self.bridge_ports[port_number].append(message)
            else:
                self.bridge_ports[port_number] = [message]

            if int(message_root, 16) < int(self.root, 16):
                self.update_bridge(message_root, message_cost, message_id, port_number)
            elif message_root == self.root and message_cost + 1 < self.cost:
                self.update_bridge(message_root, message_cost, message_id, port_number)
            elif message_root == self.root and message_cost + 1 == self.cost and int(message_id, 16) < int(self.id, 16):
                self.update_bridge(message_root, message_cost, message_id, port_number)

            self.close_ports()

        def close_ports(self):
            closed_ports = []
            highest_lan_port = 0
            for port_number, bridges in self.bridge_ports.items():
                for port_bridge in bridges:
                    if port_number != self.root_port:
                        if port_bridge['cost'] < self.cost:
                            closed_ports.append(port_number)
                        elif port_bridge['cost'] == self.cost and int(port_bridge['id'], 16) < int(self.id, 16):
                            closed_ports.append(port_number)
                        elif port_bridge['id'] == self.id:
                            if port_number > highest_lan_port:
                                closed_ports.append(highest_lan_port)
                                highest_lan_port = port_number
                            else:
                                closed_ports.append(port_number)
            if 0 in closed_ports:
                closed_ports.remove(0)
            self.closed_ports = list(set(closed_ports))

        def broadcast_all(self, message):
            for x in self.sockets:
                x.send(message)

        def broadcast_open(self, message, incoming_port):
            all_bridge_ports = []
            for port_number, bridges in self.bridge_ports.items():
                all_bridge_ports.append(port_number)
            for x in self.sockets:
                incoming_bridge_port = (x.fileno() == incoming_port)
                if not incoming_bridge_port and x.fileno() not in self.closed_ports:
                    #print 'broadcasting %s to %s' % (message, x.fileno())
                    x.send(message)

    bridge = Bridge(id, LAN)

    print "Bridge " + bridge.id + " starting up\n"

    bpdu_timer = time.time()
    time_since_bpdu = time.time()
    time.sleep(.1)  # give time for all bridges to initialize before we send initial bpdu
    bridge.send_bpdu()

    # Main loop
    debug_iteration = 1
    while True:

        ##### IS THIS LOGIC NEEDEED (send bpdu every 500ms regardless #####
        # if time.time() - bpdu_timer > .5:
        #     bridge.send_bpdu()
        #     bpdu_timer = time.time()
        #     continue

        ready, ignore, ignore2 = select.select(bridge.sockets, [], [], 1)

        # Reads from each fo the ready sockets
        for x in ready:
            data = x.recv(1500)
            port_number = x.fileno()
            parsed_data = json.loads(data)
            message_type = parsed_data['type']
            if message_type == 'bpdu':
                bridge.routing_table = {}
                bridge.recieve_bpdu(parsed_data, port_number)
            elif message_type == 'data' and port_number not in bridge.closed_ports:
                bridge.routing_table[parsed_data['source']] = x
                if parsed_data['dest'] not in bridge.routing_table:
                    bridge.broadcast_open(data, port_number)
                elif port_number != bridge.routing_table[parsed_data['dest']].fileno():
                    bridge.routing_table[parsed_data['dest']].send(data)

        #print 'debug iteration %d\n' % debug_iteration
        debug_iteration += 1
        print 'My root is: %s\n' \
              'My cost is: %s\n' \
              'My LAN Ports are: %s\n' \
              'My root port is: %s\n' \
              'My bridge ports are: %s\n' \
              'My closed ports are: %s ' \
              % (bridge.root,
                 bridge.cost,
                 bridge.lan_ports,
                 bridge.root_port,
                 bridge.bridge_ports,
                 bridge.closed_ports)
        #print 'My closed ports are: %s\nMy bridge ports are : %s' % (bridge.closed_ports, bridge.bridge_ports)
