#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import json
import time

# pads the name with null bytes at the end
def pad(name):
    result = '\0' + name
    while len(result) < 108:
        result += '\0'
    return result

if __name__ == "__main__":
    id = sys.argv[1]
    LAN = sys.argv[2:]

    class Bridge(object):
        def __init__(self, id, lan):
            self.id = id
            self.root = id
            self.cost = 0
            self.sockets = []
            self.ports = len(lan)
            self.root_port = 0
            self.designated_bridge = id
            self.bridge_ports = []
            self.closed_ports = []
            self.routing_table = {}
            for x in range(self.ports):
                s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
                s.connect(pad(lan[x]))
                self.sockets.append(s)

            self.bpdu_sockets = []

        def update_bridge(self, message_root, message_cost, message_id, port_number):
            time_since_bpdu = time.time()
            self.root = message_root
            self.cost = message_cost + 1
            self.designated_bridge = message_id
            self.root_port = port_number
            if port_number not in self.bridge_ports:
                self.bridge_ports.append(port_number)
            self.send_bpdu()

        def send_bpdu(self):
            for s in self.sockets:
                bpdu_message = {"source": self.id, "dest": 'ffff', "type": 'bpdu',
                                "message": {"id": self.id, "root": self.root, "cost": self.cost}}
                s.send(json.dumps(bpdu_message))

        def recieve_bpdu(self, data, port_number):
            message = data['message']
            message_root = message['root']
            message_cost = message['cost']
            message_id = message['id']
            if int(message_root, 16) < int(self.root, 16):
                self.update_bridge(message_root, message_cost, message_id, port_number)
            elif message_root == self.root and message_cost + 1 < self.cost:
                self.update_bridge(message_root, message_cost, message_id, port_number)
            elif message_root == self.root and message_cost + 1 == self.cost and int(message_id, 16) < int(self.id, 16):
                self.update_bridge(message_root, message_cost, message_id, port_number)

        def close_ports(self):
            self.closed_ports = self.bridge_ports
            print self.closed_ports
            print self.root_port
            try:

                if self.root_port == 0:
                    print 'Designated Bridge'
                else:
                    self.closed_ports.remove(self.root_port)
            except ValueError:
                print 'Designated Bridge'

        def broadcast_all(self, message):
            for x in self.sockets:
                x.send(message)

        def broadcast_open(self, message):
            for x in self.sockets:
                if x.fileno() not in self.closed_ports:
                    print message
                    x.send(message)

    bridge = Bridge(id, LAN)

    print "Bridge " + bridge.id + " starting up\n"

    bpdu_timer = time.time()
    time_since_bpdu = time.time()
    time.sleep(.1)  # give time for all bridges to initialize before we send initial bpdu
    bridge.send_bpdu()

    # Main loop
    debug_iteration = 1
    while True:
        # Calls select with all the sockets; change the timeout value (1)
        if time.time() - 1 > time_since_bpdu:
            bridge.close_ports()

        ##### IS THIS LOGIC NEEDEED (send bpdu every 500ms regardless #####
        # if time.time() - bpdu_timer > .5:
        #     bridge.send_bpdu()
        #     bpdu_timer = time.time()
        #     continue

        ready, ignore, ignore2 = select.select(bridge.sockets, [], [], 1)

        # Reads from each fo the ready sockets
        for x in ready:
            data = x.recv(1500)
            port_number = x.fileno()
            print 'port number: %s' % (port_number)
            parsed_data = json.loads(data)
            message_type = parsed_data['type']
            if message_type == 'bpdu':
                if x not in bridge.bpdu_sockets:
                    bridge.bpdu_sockets.append(x)
                bridge.recieve_bpdu(parsed_data, port_number)
            elif message_type == 'data':
                if parsed_data['dest'] not in bridge.routing_table:
                    bridge.broadcast_all(data)
                else:
                    bridge.routing_table[data['dest']].send(parsed_data)
                pass
            print 'debug iteration %d\n' % debug_iteration
            debug_iteration += 1
            print 'My root is: %s\n' \
                  'My cost is: %s\n' \
                  'My designated bridge is: %s\n' \
                  'My root port is: %s' \
                  % (bridge.root,
                     bridge.cost,
                     bridge.designated_bridge,
                     bridge.root_port)
