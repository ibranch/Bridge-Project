#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import json
import time

# pads the name with null bytes at the end
def pad(name):
    result = '\0' + name
    while len(result) < 108:
        result += '\0'
    return result

if __name__ == "__main__":
    id = sys.argv[1]
    LAN = sys.argv[2:]

    class Bridge(object):
        def __init__(self, id, lan):
            self.id = id
            self.root = id
            self.cost = 0
            self.sockets = []
            self.root_port = 0
            self.bridge_ports = {}
            self.closed_ports = []
            self.routing_table = {}
            self.routing_time_table = {}
            #only needed for testing
            self.lan_ports = {}

            duplicate_lan_ports = {}

            for lan_id in lan:
                if lan.count(lan_id) > 1:
                    duplicate_lan_ports[lan_id] = None
            for x in range(len(lan)):
                s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
                s.connect(pad(lan[x]))
                if lan[x] in duplicate_lan_ports:
                    print 'gets Here'
                    if duplicate_lan_ports[lan[x]] is None or s.fileno() < duplicate_lan_ports[lan[x]].fileno():
                        duplicate_lan_ports[lan[x]] = s
                else:
                    self.lan_ports[str(s.fileno())] = lan[x]
                    self.sockets.append(s)
            for lan, s in duplicate_lan_ports.items():
                self.lan_ports[str(s.fileno())] = lan
                self.sockets.append(s)

        def update_bridge(self, message_root, message_cost, message_id, port_number):
            self.clear_routing_table()
            self.root = message_root
            self.cost = message_cost + 1
            self.root_port = port_number
            self.send_bpdu()

        def send_bpdu(self):
            for s in self.sockets:
                bpdu_message = {"source": self.id, "dest": 'ffff', "type": 'bpdu',
                                "message": {"id": self.id, "root": self.root, "cost": self.cost}}
                s.send(json.dumps(bpdu_message))

        def recieve_bpdu(self, data, port_number):
            message = data['message']
            message_root = message['root']
            message_cost = message['cost']
            message_id = message['id']
            message['last_bpdu'] = time.time()
            message_last_bpdu = message['last_bpdu']

            if port_number in self.bridge_ports:
                add_bridge = True
                for bridge_port in self.bridge_ports[port_number]:
                    if bridge_port['id'] == message_id:
                        add_bridge = False
                        bridge_port['cost'] = message_cost
                        bridge_port['last_bpdu'] = message_last_bpdu
                        break
                if add_bridge:
                    self.bridge_ports[port_number].append(message)
            else:
                self.bridge_ports[port_number] = [message]

            if int(message_root, 16) < int(self.root, 16):
                self.update_bridge(message_root, message_cost, message_id, port_number)
            elif message_root == self.root and message_cost + 1 < self.cost:
                self.update_bridge(message_root, message_cost, message_id, port_number)
            elif message_root == self.root and message_cost + 1 == self.cost and int(message_id, 16) < int(self.id, 16):
                self.update_bridge(message_root, message_cost, message_id, port_number)

            self.close_ports()

        def close_ports(self):
            closed_ports = []
            for port_number, bridges in self.bridge_ports.items():
                for port_bridge in bridges:
                    if port_number != self.root_port:
                        if port_bridge['cost'] < self.cost:
                            closed_ports.append(port_number)
                        elif port_bridge['cost'] == self.cost and int(port_bridge['id'], 16) < int(self.id, 16):
                            closed_ports.append(port_number)

            self.closed_ports = list(set(closed_ports))

        def broadcast_open(self, message, incoming_port):
            all_bridge_ports = []
            for port_number, bridges in self.bridge_ports.items():
                all_bridge_ports.append(port_number)
            for x in self.sockets:
                incoming_bridge_port = (x.fileno() == incoming_port)
                if not incoming_bridge_port and x.fileno() not in self.closed_ports:
                    x.send(message)

        def clear_routing_table(self):
            self.routing_table = {}
            self.routing_time_table = {}

    bridge = Bridge(id, LAN)

    print "Bridge " + bridge.id + " starting up\n"

    bpdu_timer = time.time()
    bridge.send_bpdu()

    # Main loop
    debug_iteration = 1
    while True:

        ##### IS THIS LOGIC NEEDEED (send bpdu every 500ms regardless #####
        if time.time() - bpdu_timer > .5:
            bridge.send_bpdu()
            bpdu_timer = time.time()
            continue
        for port_number, bridges in bridge.bridge_ports.items():
            for port_bridge in bridges:
                if time.time() - port_bridge['last_bpdu'] > .75:
                    print "BRIDGE %s IS SHUTTING DOWN" % port_bridge['id']
                    bridges.remove(port_bridge)
                    bridge.clear_routing_table()
                    bridge.send_bpdu()
                    bpdu_timer = time.time()
                    continue
        for host, last_sent in bridge.routing_time_table.items():
            if time.time() - last_sent > 5:
                print 'DELETE HOST'
                bridge.routing_time_table.pop(host, None)

        ready, ignore, ignore2 = select.select(bridge.sockets, [], [], 1)

        # Reads from each fo the ready sockets
        for x in ready:
            data = x.recv(1500)
            port_number = x.fileno()
            parsed_data = json.loads(data)
            message_type = parsed_data['type']
            if message_type == 'bpdu':
                bridge.recieve_bpdu(parsed_data, port_number)
            elif message_type == 'data' and port_number not in bridge.closed_ports:
                bridge.routing_table[parsed_data['source']] = x
                bridge.routing_time_table[parsed_data['source']] = time.time()
                if parsed_data['dest'] not in bridge.routing_table:
                    bridge.broadcast_open(data, port_number)
                elif port_number != bridge.routing_table[parsed_data['dest']].fileno():
                    bridge.routing_table[parsed_data['dest']].send(data)

        #print 'debug iteration %d\n' % debug_iteration
        debug_iteration += 1
        # print 'My root is: %s\n' \
        #       'My cost is: %s\n' \
        #       'My LAN Ports are: %s\n' \
        #       'My root port is: %s\n' \
        #       'My bridge ports are: %s\n' \
        #       'My closed ports are: %s ' \
        #       % (bridge.root,
        #          bridge.cost,
        #          bridge.lan_ports,
        #          bridge.root_port,
        #          bridge.bridge_ports,
        #          bridge.closed_ports)
        #print 'My closed ports are: %s\nMy bridge ports are : %s' % (bridge.closed_ports, bridge.bridge_ports)
