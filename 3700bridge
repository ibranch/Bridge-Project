#!/usr/bin/python -u
# The -u makes output unbuffered, so it will show up immediately
import sys
import socket
import select
import json
import time

# pads the name with null bytes at the end
def pad(name):
    result = '\0' + name
    while len(result) < 108:
        result += '\0'
    return result

if __name__ == "__main__":
    id = sys.argv[1]
    LAN = sys.argv[2:]

    class Bridge(object):
        def __init__(self, id, lan):
            self.id = id
            self.root = id
            self.cost = 0
            self.sockets = []
            self.ports = len(lan)
            self.root_port = 0
            for x in range(self.ports):
                s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
                s.connect(pad(lan[x]))
                self.sockets.append(s)

        def update_bridge(self, message_root, message_cost, message_id):
            self.root = message_root
            self.cost = message_cost + 1
            self.root_port = message_id
            self.send_bpdu()

        def send_bpdu(self):
            for s in self.sockets:
                bpdu_message = {"source": self.id, "dest": 'ffff', "type": 'bpdu',
                                "message": {"id": self.id, "root": self.root, "cost": self.cost}}
                s.send(json.dumps(bpdu_message))

        def recieve_bpdu(self, data):
            message = data['message']
            message_root = message['root']
            message_cost = message['cost']
            message_id = message['id']
            if int(message_root, 16) < int(self.root, 16):
                self.update_bridge(message_root, message_cost, message_id)
            elif message_root == self.root and message_cost < self.cost:
                self.update_bridge(message_root, message_cost, message_id)
            elif message_root == self.root and message_cost == self.cost and int(message_id, 16) < int(self.id, 16):
                self.update_bridge(message_root, message_cost, message_id)

    bridge = Bridge(id, LAN)
    time.sleep(1)
    bridge.send_bpdu()

    print "Bridge " + bridge.id + " starting up\n"
    # Main loop
    while True:
        # Calls select with all the sockets; change the timeout value (1)
        ready, ignore, ignore2 = select.select(bridge.sockets, [], [], 1)

        # Reads from each fo the ready sockets
        for x in ready:
            data = x.recv(1500)
            parsed_data = json.loads(data)
            message_type = parsed_data['type']
            if message_type == 'bpdu':
                bridge.recieve_bpdu(parsed_data)
            else:
                print 'My root is: %s My cost is: %s My root port is is: %s ' % (bridge.root, bridge.cost, bridge.root_port)

